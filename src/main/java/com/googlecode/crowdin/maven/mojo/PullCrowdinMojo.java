package com.googlecode.crowdin.maven.mojo;

import com.googlecode.crowdin.maven.service.GitService;
import com.googlecode.crowdin.maven.dao.pull.PullTranslationDAO;
import com.googlecode.crowdin.maven.dao.pull.PullTranslationDAOCrowdin;
import com.googlecode.crowdin.maven.dao.GazelleLogger;
import com.googlecode.crowdin.maven.dao.CrowdinApiUtils;
import com.googlecode.crowdin.maven.tool.SortedProperties;
import com.googlecode.crowdin.maven.tool.SpecialArtifact;
import com.googlecode.crowdin.maven.tool.TranslationFile;
import org.apache.maven.artifact.Artifact;
import org.apache.maven.artifact.resolver.filter.ArtifactFilter;
import org.apache.maven.artifact.resolver.filter.ScopeArtifactFilter;
import org.apache.maven.execution.MavenSession;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.MojoFailureException;
import org.apache.maven.plugins.annotations.Component;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.project.DefaultProjectBuildingRequest;
import org.apache.maven.project.ProjectBuildingRequest;
import org.apache.maven.shared.dependency.graph.DependencyGraphBuilder;
import org.apache.maven.shared.dependency.graph.DependencyGraphBuilderException;
import org.apache.maven.shared.dependency.graph.DependencyNode;
import org.apache.maven.shared.dependency.graph.traversal.CollectingDependencyNodeVisitor;

import java.io.*;
import java.util.*;
import java.util.Map.Entry;
import java.util.logging.Logger;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

/**
 * Pull crowdin translations in this project, looking dependencies
 */
@Mojo(name = "pull", threadSafe = true, defaultPhase = LifecyclePhase.COMPILE)
public class PullCrowdinMojo extends AbstractCrowdinMojo {

    public static final String COMMENT = "This file is automatically generated. Please do not edit this file. "
            + "If you'd like to change the content please use crowdin";

    @Parameter(defaultValue = "${session}", readonly = true, required = true)
    private MavenSession session;

    @Component(hint = "default")
    private DependencyGraphBuilder dependencyGraphBuilder;

    private PullTranslationDAO pullTranslationDAO;

    private final GitService gitService = new GitService();

    @Override
    public void execute() throws MojoExecutionException, MojoFailureException {
        super.execute();
        Logger log = new GazelleLogger(getLog());
        PullTranslationDAO crowdinDAO = getCrowdinPullDAO(log);

        if (messagesInputDirectory.exists()) {
            log.info("Downloading translations from crowdin (branch : " + gitService.getCurrentGitBranch() + ")");
            Map<TranslationFile, byte[]> translations = pullTranslations(crowdinDAO);

            Set<Artifact> dependencyArtifacts = getAllDependencies();
            Set<String> mavenIds = new HashSet<>();
            for (Artifact artifact : dependencyArtifacts) {
                String mavenId = getMavenId(artifact);
                mavenIds.add(mavenId);
            }

            Map<TranslationFile, byte[]> usedTranslations = new HashMap<>(translations);

            for (TranslationFile translationFile : translations.keySet()) {
                if (!mavenIds.contains(translationFile.getMavenId())) {
                    getLog().debug(translationFile.getMavenId() + " is not a dependency");
                    usedTranslations.remove(translationFile);
                } else {
                    getLog().debug(translationFile.getMavenId() + " is a dependency");
                }
            }

            translations = usedTranslations;
            if (translations.isEmpty()) {
                getLog().info("No translations available for this project!");
            } else {
                getLog().info("Cleaning crowdin folder.");
                cleanFolders(translations.keySet());

                try {
                    getLog().info("Copying translations to crowdin folder.");
                    copyTranslations(translations);
                } catch (IOException e) {
                    throw new MojoExecutionException("Failed to write file", e);
                }
            }
        } else {
            getLog().info(messagesInputDirectory.getPath() + " not found - skipping pull");
        }
    }

    /**
     * Clean folders that are not in the list of translation files
     * @param translationFiles list of translation files
     */
    private void cleanFolders(Set<TranslationFile> translationFiles) {
        if (messagesOutputDirectory.exists()) {
            File[] languageFolders = messagesOutputDirectory.listFiles();
            if (languageFolders != null) {
                for (File languageFolder : languageFolders) {
                    if (!languageFolder.getName().startsWith(".") && languageFolder.isDirectory()) {
                        if (!containsLanguage(translationFiles, languageFolder.getName())) {
                            deleteFolder(languageFolder, true);
                        } else {
                            cleanLanguageFolder(languageFolder, translationFiles);
                        }
                    }
                }
            }
        }
    }

    /**
     * Clean mavenId folders that are not in the list of translation files
     * @param languageFolder language folder
     * @param translationFiles list of translation files
     */
    private void cleanLanguageFolder(File languageFolder, Set<TranslationFile> translationFiles) {
        File[] mavenIds = languageFolder.listFiles();
        if (mavenIds != null) {
            for (File mavenId : mavenIds) {
                if (!mavenId.getName().startsWith(".") && mavenId.isDirectory()) {
                    boolean deleteRoot = !containsMavenId(translationFiles, mavenId.getName());
                    deleteFolder(mavenId, deleteRoot);
                }
            }
        }
    }

    /**
     * Check if a language is in the list of translation files
     * @param translationFiles list of translation files
     * @param language language to check
     * @return true if the language is in the list of translation files
     */
    private boolean containsLanguage(Set<TranslationFile> translationFiles, String language) {
        for (TranslationFile translationFile : translationFiles) {
            if (translationFile.getLanguage().equals(language)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Check if a mavenId is in the list of translation files
     * @param translationFiles list of translation files
     * @param mavenId mavenId to check
     * @return true if the mavenId is in the list of translation files
     */
    private boolean containsMavenId(Set<TranslationFile> translationFiles, String mavenId) {
        for (TranslationFile translationFile : translationFiles) {
            if (translationFile.getMavenId().equals(mavenId)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Delete a folder and its content
     * @param folder folder to delete
     * @param deleteRoot true if the root folder should be deleted
     */
    private void deleteFolder(File folder, boolean deleteRoot) {
        File[] listFiles = folder.listFiles();
        if (listFiles != null) {
            for (File file : listFiles) {
                if (!file.getName().startsWith(".") || deleteRoot) {
                    if (file.isDirectory()) {
                        deleteFolder(file, true);
                    }
                    getLog().debug("Deleted " + file);
                }
            }
        }
        if (deleteRoot) {
            folder.delete();
            getLog().debug("Deleted " + folder);
        }
    }

    /**
     * Pull translations from crowdin
     * @return map of translation files and their content
     * @throws MojoExecutionException if the pull of translations fails
     */
    private Map<TranslationFile, byte[]> pullTranslations(PullTranslationDAO crowdinDAO) throws MojoExecutionException {
        try {
            Map<TranslationFile, byte[]> translations = new HashMap<>();
            String buildId = crowdinDAO.buildTranslations();
            InputStream responseBodyAsStream = crowdinDAO.downloadTranslations(buildId);
            ZipInputStream zis = new ZipInputStream(responseBodyAsStream);
            ZipEntry entry;
            while ((entry = zis.getNextEntry()) != null) {
                if (!entry.isDirectory()) {

                    String name = entry.getName();
                    getLog().debug("Processing " + name);
                    int slash = name.indexOf('/');
                    String language = name.substring(0, slash);
                    name = name.substring(slash + 1);
                    slash = name.indexOf('/');
                    if (slash > 0) {
                        String mavenId = name.substring(0, slash);
                        name = name.substring(slash + 1);
                        TranslationFile translationFile = new TranslationFile(language, mavenId, name);

                        ByteArrayOutputStream bos = new ByteArrayOutputStream();
                        while (zis.available() > 0) {
                            int read = zis.read();
                            if (read != -1) {
                                bos.write(read);
                            }
                        }
                        bos.close();
                        translations.put(translationFile, bos.toByteArray());
                    }
                }
            }
            return translations;
        } catch (Exception e) {
            throw new MojoExecutionException("Failed to call API", e);
        }
    }

    /**
     * Copy translations to the output directory
     * @param translations map of translation files and their content
     * @throws IOException if the write of the files fails
     */
    private void copyTranslations(Map<TranslationFile, byte[]> translations) throws IOException {
        Set<Entry<TranslationFile, byte[]>> entrySet = translations.entrySet();
        for (Entry<TranslationFile, byte[]> entry : entrySet) {
            TranslationFile translationFile = entry.getKey();

            byte[] bytes = entry.getValue();
            SortedProperties properties = new SortedProperties();
            InputStream inStream = new ByteArrayInputStream(bytes);
            properties.load(inStream);
            inStream.close();

            File languageFolder = new File(messagesOutputDirectory, translationFile.getLanguage());
            if (!languageFolder.exists()) {
                languageFolder.mkdirs();
            }
            File mavenIdFolder = new File(languageFolder, translationFile.getMavenId());
            if (!mavenIdFolder.exists()) {
                mavenIdFolder.mkdirs();
            }
            File targetFile = new File(mavenIdFolder, translationFile.getName());

            getLog().info(
                    "Importing from crowdin " + translationFile.getLanguage() + "/" + translationFile.getMavenId()
                            + "/" + translationFile.getName());

            FileOutputStream out = new FileOutputStream(targetFile);
            properties.store(out, COMMENT);
            out.close();

        }
    }

    /**
     * Get all dependencies of the project
     * @return set of dependencies
     * @throws MojoExecutionException if the dependencies cannot be retrieved
     */
    private Set<Artifact> getAllDependencies() throws MojoExecutionException {
        Set<Artifact> result = new HashSet<>();
        try {
            ArtifactFilter artifactFilter = new ScopeArtifactFilter(Artifact.SCOPE_COMPILE);

            ProjectBuildingRequest buildingRequest = new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());
            buildingRequest.setProject(project);
            DependencyNode rootNode = dependencyGraphBuilder.buildDependencyGraph(buildingRequest, artifactFilter);

            CollectingDependencyNodeVisitor visitor = new CollectingDependencyNodeVisitor();

            rootNode.accept(visitor);

            List<DependencyNode> nodes = visitor.getNodes();
            for (DependencyNode dependencyNode : nodes) {
                result.add(new SpecialArtifact(dependencyNode.getArtifact()));
            }
        } catch (DependencyGraphBuilderException e) {
            throw new MojoExecutionException("Failed to get dependencies", e);
        }
        return result;
    }

    /**
     * Get the DAO to pull files in crowdin (Factory)
     * @return the DAO to push files in crowdin
     */
    private PullTranslationDAO getCrowdinPullDAO(Logger logger) {
        if (pullTranslationDAO == null)
            pullTranslationDAO = new PullTranslationDAOCrowdin(logger,CrowdinApiUtils.getServerUrl(),
                    authenticationInfo.getUserName(),
                    authenticationInfo.getPassword());
        return pullTranslationDAO;
    }
}
